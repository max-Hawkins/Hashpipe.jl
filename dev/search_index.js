var documenterSearchIndex = {"docs":
[{"location":"#Hashpipe.jl's-Documentation","page":"Hashpipe.jl's Documentation","title":"Hashpipe.jl's Documentation","text":"","category":"section"},{"location":"","page":"Hashpipe.jl's Documentation","title":"Hashpipe.jl's Documentation","text":"CurrentModule = Hashpipe","category":"page"},{"location":"","page":"Hashpipe.jl's Documentation","title":"Hashpipe.jl's Documentation","text":"Modules = [Hashpipe]","category":"page"},{"location":"#Hashpipe.Hashpipe","page":"Hashpipe.jl's Documentation","title":"Hashpipe.Hashpipe","text":"Hashpipe Module\n\nC Hashpipe functions for the High-Availablity Shared Pipeline Engine ported for Julia usability with pure-Julian extensions. Written by Max Hawkins Hashpipe C code written by Dave MacMahon: https://github.com/david-macmahon/hashpipe\n\n\n\n\n\n","category":"module"},{"location":"#Hashpipe.HASHPIPE_ERR_GEN","page":"Hashpipe.jl's Documentation","title":"Hashpipe.HASHPIPE_ERR_GEN","text":"HASHPIPE_ERR_GEN\n\nStatus code signifying an unknown error?\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.HASHPIPE_ERR_KEY","page":"Hashpipe.jl's Documentation","title":"Hashpipe.HASHPIPE_ERR_KEY","text":"HASHPIPE_ERR_KEY\n\nStatus code signifying requested key doesn't exist.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.HASHPIPE_ERR_PACKET","page":"Hashpipe.jl's Documentation","title":"Hashpipe.HASHPIPE_ERR_PACKET","text":"HASHPIPE_ERR_PACKET\n\nStatus code signifying unexpected packet size.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.HASHPIPE_ERR_PARAM","page":"Hashpipe.jl's Documentation","title":"Hashpipe.HASHPIPE_ERR_PARAM","text":"HASHPIPE_ERR_PARAM\n\nStatus code signifying parameter out of valid range.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.HASHPIPE_ERR_SYS","page":"Hashpipe.jl's Documentation","title":"Hashpipe.HASHPIPE_ERR_SYS","text":"HASHPIPE_ERR_SYS\n\nStatus code signifying a failed system call.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.HASHPIPE_OK","page":"Hashpipe.jl's Documentation","title":"Hashpipe.HASHPIPE_OK","text":"HASHPIPE_OK\n\nStatus code signifying successful operation.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.HASHPIPE_TIMEOUT","page":"Hashpipe.jl's Documentation","title":"Hashpipe.HASHPIPE_TIMEOUT","text":"HASHPIPE_TIMEOUT\n\nStatus code signifying call timeout.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.MAX_HASHPIPE_THREADS","page":"Hashpipe.jl's Documentation","title":"Hashpipe.MAX_HASHPIPE_THREADS","text":"MAX_HASHPIPE_THREADS\n\nMaximum number of threads that be defined by plugins.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.STATUS_RECORD_SIZE","page":"Hashpipe.jl's Documentation","title":"Hashpipe.STATUS_RECORD_SIZE","text":"const global STATUS_RECORD_SIZE = 80\n\nThe size of a status record - 80 characters.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.STATUS_TOTAL_SIZE","page":"Hashpipe.jl's Documentation","title":"Hashpipe.STATUS_TOTAL_SIZE","text":"const global STATUS_TOTAL_SIZE = 184320\n\nThe maximum size of a HASHPIPE status buffer - 184,320 bytes.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.THREAD_ERROR","page":"Hashpipe.jl's Documentation","title":"Hashpipe.THREAD_ERROR","text":"THREAD_ERROR\n\nError status from run.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.THREAD_OK","page":"Hashpipe.jl's Documentation","title":"Hashpipe.THREAD_OK","text":"THREAD_OK\n\nOK status from run.\n\n\n\n\n\n","category":"constant"},{"location":"#Hashpipe.HashpipeThread","page":"Hashpipe.jl's Documentation","title":"Hashpipe.HashpipeThread","text":"HashpipeThread\n\nAbstract type describing a Hashpipe thread.\n\nname - A string containing the thread's name. Used to match command line\n        thread spcifiers to thread metadata so that the pipeline can be \n        constructed as specified on the command line.\nskey - A string containing the thread's status buffer \"status\" key.\n        Typically 8 characters or less, uppercase, and ends with \"STAT\".\n        If it is non-NULL and non-empty, HASHPIPE will automatically \n        store/update this key in the status buffer with the thread's \n        status at initialization (\"init\") and exit (\"exit\").\ninit - A pointer to the thread's initialization function.\nrun  - A pointer to the thread's run function.\nibuf - A structure describing the thread's input data buffer (if any).\nobuf - A structure describing the thread's output data buffer (if any).\n\nDescription of Hashpipe threads\n\nA hashpipe_thread structure encapsulates metadata and functionality for one or more threads that can be used in a processing pipeline.  The hashpipe executable dynamically assembles a pipeline at runtime consisting of multiple hashpipe threads.\n\nHashpipe threads must register themselves with the hashpipe executable via a call to registerhashpipethread().  This is typically performed from a static C function with the constructor attribute in the hashpipe thread's source file.\n\nHashpipe threads are identified by their name.  The hashpipe executable finds (registered) hashpipe threads by their name.  A hashpipe thread can be input-only, output-only, or both input and output.  An input thread has an associated output data buffer into which it writes data.  An output thread has an associated input data buffer from which it reads data.  An input/output thread has both.\n\nInput-only threads source data into the pipeline.  They do not get their input data from a shared memory ring buffer.  They get their data from external sources (e.g.  files or the network) or generate it internally (e.g.  for test vectors).  Input-only threads have an output data buffer, but no input data buffer (their input does not come from a shared memory ring buffer).\n\nOutput-only threads sink data from the pipeline.  Thy do not put their output data into a shared memory ring buffer.  They send their data to external sinks (e.g. files or the network) of consume it internally (e.g. comparing against expected output).  Output-only threads have an input data buffer, but no output data buffer (their output data does not go the a shared memory ring buffer).\n\nInput/output threads get their input data from one shared memory region (their input data buffer), process it, and store the output data in another shared memory region (their output data buffer).\n\n\n\n\n\n","category":"type"},{"location":"#Hashpipe.databuf_desc_t","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_desc_t","text":"struct databuf_desc_t\n\nContain the pointer to the databuf create function.\n\n\n\n\n\n","category":"type"},{"location":"#Hashpipe.databuf_t","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_t","text":"databuf_t <: HashpipeDatabuf\n\nContain data pertaining to a Hashpipe databuffer.\n\n\n\n\n\n","category":"type"},{"location":"#Hashpipe.status_t","page":"Hashpipe.jl's Documentation","title":"Hashpipe.status_t","text":"Hashpipe Status struct\n\nData representing a Hashpipe status buffer.\n\nNeed to create empty status struct before trying to attaching to existing status buffer. Example: '''     instanceid = 0     status = statust(0,0,0,0)     statusattach(instanceid, Ref(status)) '''\n\n\n\n\n\n","category":"type"},{"location":"#Hashpipe.thread_args_t","page":"Hashpipe.jl's Documentation","title":"Hashpipe.thread_args_t","text":"thread_args_t\n\nImplementation data for a Hashpipe thread.\n\n\n\n\n\n","category":"type"},{"location":"#Hashpipe.thread_desc_t","page":"Hashpipe.jl's Documentation","title":"Hashpipe.thread_desc_t","text":"thread_desc_t\n\nMetadata describing a Hashpipe thread (usually defined by a plugin per thread).\n\nThe thread_desc structure is used to store metadata describing a hashpipe thread.   Typically a hashpipe plugin will define one of these hashpipe thread  descriptors per hashpipe thread.\n\n\n\n\n\n","category":"type"},{"location":"#Base.Multimedia.display-Tuple{Ptr{databuf_t}}","page":"Hashpipe.jl's Documentation","title":"Base.Multimedia.display","text":"Base.display(p::Ptr{databuf_t})\n\nDisplay Hashpipe databuffer from pointer nicely in REPL.\n\n\n\n\n\n","category":"method"},{"location":"#Base.Multimedia.display-Tuple{Ref{status_t}}","page":"Hashpipe.jl's Documentation","title":"Base.Multimedia.display","text":"Base.display(r::Ref{status_t})\n\nDisplay Hashpipe status from reference nicely in REPL.\n\n\n\n\n\n","category":"method"},{"location":"#Base.Multimedia.display-Tuple{databuf_t}","page":"Hashpipe.jl's Documentation","title":"Base.Multimedia.display","text":"Base.display(d::Hashpipe.databuf_t)\n\nDisplay a Hashpipe databuffer nicely in REPL.\n\n\n\n\n\n","category":"method"},{"location":"#Base.Multimedia.display-Tuple{status_t}","page":"Hashpipe.jl's Documentation","title":"Base.Multimedia.display","text":"Base.display(s::status_t)\n\nDisplay a Hashpipe status nicely in REPL.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.check_databuf","page":"Hashpipe.jl's Documentation","title":"Hashpipe.check_databuf","text":"check_databuf(instance_id=0, db_id=1)\n\nDisplay databuf information of a given databuf of a Hashpipe instance.\n\n\n\n\n\n","category":"function"},{"location":"#Hashpipe.databuf_attach-Tuple{Int64, Int64}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_attach","text":"databuf_attach(instance_id::Int, db_id::Int)\n\nAttach a databuf to a Hashpipe instance.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_block_status-Tuple{Ptr{databuf_t}, Int64}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_block_status","text":"databuf_block_status(p_databuf::Ptr{databuf_t}, block_id::Int)\n\nReturn the status of the selected data block of the given databuffer.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_clear-Tuple{Ptr{databuf_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_clear","text":"databuf_clear(p_databuf::Ptr{databuf_t})\n\nClear the data in a databuf.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_create-NTuple{5, Int64}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_create","text":"databuf_create(instance_id::Int, db_id::Int, header_size::Int, block_size::Int, n_block::Int)\n\nCreate a databuffer with given parameters.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_data-Tuple{Ptr{databuf_t}, Int64}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_data","text":"databuf_data(p_databuf::Ptr{databuf_t}, block_id::Int)\n\nReturn the pointer to the associated databuffer's block's data.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_detach-Tuple{Ptr{databuf_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_detach","text":"databuf_detach(instance_id::Int, db_id::Int)\n\nDetach a databuf from a Hashpipe instance.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_set_filled-Tuple{Ptr{databuf_t}, Int64}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_set_filled","text":"databuf_set_filled(p_databuf::Ptr{databuf_t}, block_id::Int)\n\nSet the given block of data as filled. Return an error if the block is already filled.\n\nSee also: databuf_wait_filled, databuf_wait_free, databuf_set_free\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_set_free-Tuple{Ptr{databuf_t}, Int64}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_set_free","text":"databuf_set_free(p_databuf::Ptr{databuf_t}, block_id::Int)\n\nSet the given block of data as free. Return an error if the block is already free.\n\nSee also: databuf_wait_filled, databuf_wait_free, databuf_set_filled\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_total_mask-Tuple{Ptr{databuf_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_total_mask","text":"databuf_total_mask(p_databuf::Ptr{databuf_t})\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_total_status-Tuple{Ptr{databuf_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_total_status","text":"databuf_total_status(p_databuf::Ptr{databuf_t})\n\nReturn the total lock status for the given databuffer.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_wait_filled-Tuple{Ptr{databuf_t}, Int64}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_wait_filled","text":"databuf_wait_filled(p_databuf::Ptr{databuf_t}, block_id::Int)\n\nWait for the given block of data to be filled.\n\nSee also: databuf_wait_free, databuf_set_filled, databuf_set_free\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.databuf_wait_free-Tuple{Ptr{databuf_t}, Int64}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.databuf_wait_free","text":"databuf_wait_free(p_databuf::Ptr{databuf_t}, block_id::Int)\n\nWait for the given block of data to be freed.\n\nSee also: databuf_wait_filled, databuf_set_filled, databuf_set_free\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.find_hashpipe_thread-Tuple{Any}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.find_hashpipe_thread","text":"find_hashpipe_thread(name)\n\nFind a Hashpipe thread with the given name.\n\nGenerally used only by the hashpipe executable.  Returns a pointer to its hashpipethreaddesc_t structure or NULL if a test with the given name is not found.\n\nNames are case-sensitive.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.get_cpu_affinity-Tuple{}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.get_cpu_affinity","text":"get_cpu_affinity()\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.register_hashpipe_thread-Tuple{Any}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.register_hashpipe_thread","text":"register_hashpipe_thread(ptm)\n\nRegister a Hashpipe thread with the pipeline executable.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.run_threads-Tuple{}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.run_threads","text":"run_threads()\n\nFunction that threads use to determine whether to keep running.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.status_attach-Tuple{Int64, Ref{status_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.status_attach","text":"status_attach(instance_id::Int, p_status::Ref{status_t})\n\nPopulate the Hashpipe status pointed to by p_status with the status values of the Hashpipe instance given (created if doesn't already exist).\n\nAttach/create lock semaphore as well.  Return nonzero on error.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.status_buf_lock_unlock-Tuple{Function, Ref{status_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.status_buf_lock_unlock","text":"status_buf_lock_unlock(f::Function, r_status::Ref{status_t})\n\nSafely lock and unlock a shared status buffer for updating its values. This must be done so that the status buffer values aren't changed by multiple processes at the same time.\n\nExample:\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.status_chkinit-Tuple{Ref{status_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.status_chkinit","text":"status_chkinit(p_status::Ref{status_t})\n\nCheck the status buffer for appropriate formatting (existence of \"END\"). If not found, zero it out and add END.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.status_clear-Tuple{Ref{status_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.status_clear","text":"status_clear(p_status::Ref{status_t})\n\nClear the status values of the status buffer shared memory.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.status_exists-Tuple{Int64}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.status_exists","text":"status_exists(instance_id)\n\nCheck whether or not the Hashpipe status buffer exists for the given Hashpipe instance.\n\nReturns non-zero if the status buffer for instance already exists.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.status_lock-Tuple{Ref{status_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.status_lock","text":"status_lock(p_status::Ref{status_t})\n\nLock the status pointed to by p_status (probably for updating status values).\n\nIf locked, will sleep while waiting for the buffer to become unlocked.\n\n\n\n\n\n","category":"method"},{"location":"#Hashpipe.status_unlock-Tuple{Ref{status_t}}","page":"Hashpipe.jl's Documentation","title":"Hashpipe.status_unlock","text":"status_unlock(p_status::Ref{status_t})\n\nUnlock the status pointed to by p_status (probably after updating status values).\n\nIf unlocked, will sleep while waiting for the buffer to become locked.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Hashpipe.jl's Documentation","title":"Hashpipe.jl's Documentation","text":"","category":"page"}]
}
